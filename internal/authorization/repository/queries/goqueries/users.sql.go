// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: users.sql

package goqueries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addBindingAttempt = `-- name: AddBindingAttempt :exec
INSERT INTO binding_attempts (
    tg_id,
    code,
    password_hash
) VALUES (
    $1,
    $2,
    $3
)
`

type AddBindingAttemptParams struct {
	TgID         int32  `db:"tg_id"`
	Code         string `db:"code"`
	PasswordHash string `db:"password_hash"`
}

func (q *Queries) AddBindingAttempt(ctx context.Context, db DBTX, arg AddBindingAttemptParams) error {
	_, err := db.Exec(ctx, addBindingAttempt, arg.TgID, arg.Code, arg.PasswordHash)
	return err
}

const addUser = `-- name: AddUser :one
INSERT INTO users (
    tg_id,
    tg_nickname
)
VALUES (
    $1,
    $2
)
RETURNING id, password_hash, tg_id, timezone_offset, timezone_dst, tg_nickname, daily_notification_time
`

type AddUserParams struct {
	TgID       int32  `db:"tg_id"`
	TgNickname string `db:"tg_nickname"`
}

func (q *Queries) AddUser(ctx context.Context, db DBTX, arg AddUserParams) (User, error) {
	row := db.QueryRow(ctx, addUser, arg.TgID, arg.TgNickname)
	var i User
	err := row.Scan(
		&i.ID,
		&i.PasswordHash,
		&i.TgID,
		&i.TimezoneOffset,
		&i.TimezoneDst,
		&i.TgNickname,
		&i.DailyNotificationTime,
	)
	return i, err
}

const findUser = `-- name: FindUser :one
SELECT id, password_hash, tg_id, timezone_offset, timezone_dst, tg_nickname, daily_notification_time
FROM users
WHERE tg_nickname = $1
   OR tg_id = $2
`

type FindUserParams struct {
	TgNickname string `db:"tg_nickname"`
	TgID       int32  `db:"tg_id"`
}

func (q *Queries) FindUser(ctx context.Context, db DBTX, arg FindUserParams) (User, error) {
	row := db.QueryRow(ctx, findUser, arg.TgNickname, arg.TgID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.PasswordHash,
		&i.TgID,
		&i.TimezoneOffset,
		&i.TimezoneDst,
		&i.TgNickname,
		&i.DailyNotificationTime,
	)
	return i, err
}

const getLatestBindingAttempt = `-- name: GetLatestBindingAttempt :one
SELECT id, tg_id, login_timestamp, code, done, password_hash
FROM binding_attempts
WHERE tg_id = $1
ORDER BY login_timestamp DESC
LIMIT 1
`

func (q *Queries) GetLatestBindingAttempt(ctx context.Context, db DBTX, tgID int32) (BindingAttempt, error) {
	row := db.QueryRow(ctx, getLatestBindingAttempt, tgID)
	var i BindingAttempt
	err := row.Scan(
		&i.ID,
		&i.TgID,
		&i.LoginTimestamp,
		&i.Code,
		&i.Done,
		&i.PasswordHash,
	)
	return i, err
}

const getLoginParameters = `-- name: GetLoginParameters :one
SELECT id,
       password_hash
FROM users
WHERE tg_nickname = $1
`

type GetLoginParametersRow struct {
	ID           int32       `db:"id"`
	PasswordHash pgtype.Text `db:"password_hash"`
}

func (q *Queries) GetLoginParameters(ctx context.Context, db DBTX, tgNickname string) (GetLoginParametersRow, error) {
	row := db.QueryRow(ctx, getLoginParameters, tgNickname)
	var i GetLoginParametersRow
	err := row.Scan(&i.ID, &i.PasswordHash)
	return i, err
}

const getNearestDailyNotificationTime = `-- name: GetNearestDailyNotificationTime :one
(
    SELECT daily_notification_time
    FROM users as a
    WHERE a.daily_notification_time > CURRENT_TIME
    ORDER BY daily_notification_time
    LIMIT 1
)
UNION ALL
(
    SELECT daily_notification_time
    FROM users
    WHERE daily_notification_time > '00:00:00+00:00'
    ORDER BY daily_notification_time
    LIMIT 1
)
ORDER BY daily_notification_time DESC
LIMIT 1
`

func (q *Queries) GetNearestDailyNotificationTime(ctx context.Context, db DBTX) (string, error) {
	row := db.QueryRow(ctx, getNearestDailyNotificationTime)
	var daily_notification_time string
	err := row.Scan(&daily_notification_time)
	return daily_notification_time, err
}

const listUsersToNotfiy = `-- name: ListUsersToNotfiy :many
SELECT id, password_hash, tg_id, timezone_offset, timezone_dst, tg_nickname, daily_notification_time
FROM users
WHERE daily_notification_time = $1
`

func (q *Queries) ListUsersToNotfiy(ctx context.Context, db DBTX, now string) ([]User, error) {
	rows, err := db.Query(ctx, listUsersToNotfiy, now)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.PasswordHash,
			&i.TgID,
			&i.TimezoneOffset,
			&i.TimezoneDst,
			&i.TgNickname,
			&i.DailyNotificationTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBindingAttempt = `-- name: UpdateBindingAttempt :exec
UPDATE binding_attempts
SET done = $1
WHERE id = $2
`

type UpdateBindingAttemptParams struct {
	Done bool  `db:"done"`
	ID   int32 `db:"id"`
}

func (q *Queries) UpdateBindingAttempt(ctx context.Context, db DBTX, arg UpdateBindingAttemptParams) error {
	_, err := db.Exec(ctx, updateBindingAttempt, arg.Done, arg.ID)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET tg_nickname = $1,
    password_hash = $2,
    timezone_offset = $3,
    timezone_dst = $4
WHERE tg_id = $5
`

type UpdateUserParams struct {
	TgNickname     string      `db:"tg_nickname"`
	PasswordHash   pgtype.Text `db:"password_hash"`
	TimezoneOffset int32       `db:"timezone_offset"`
	TimezoneDst    bool        `db:"timezone_dst"`
	TgID           int32       `db:"tg_id"`
}

func (q *Queries) UpdateUser(ctx context.Context, db DBTX, arg UpdateUserParams) error {
	_, err := db.Exec(ctx, updateUser,
		arg.TgNickname,
		arg.PasswordHash,
		arg.TimezoneOffset,
		arg.TimezoneDst,
		arg.TgID,
	)
	return err
}
