// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: notification.sql

package goqueries

import (
	"context"
	"time"
)

const listNotSentNotifications = `-- name: ListNotSentNotifications :many
SELECT e.id as event_id, e.next_sending, t.text, u.tg_id, u.notification_retry_period_s
FROM events AS e
JOIN tasks AS t
    ON e.task_id = t.id
JOIN users AS u
    ON t.user_id = u.id 
WHERE e.done = 0
  AND e.next_sending <= ?1
ORDER BY e.next_sending DESC
`

type ListNotSentNotificationsRow struct {
	EventID                  int64     `db:"event_id"`
	NextSending              time.Time `db:"next_sending"`
	Text                     string    `db:"text"`
	TgID                     int64     `db:"tg_id"`
	NotificationRetryPeriodS int64     `db:"notification_retry_period_s"`
}

func (q *Queries) ListNotSentNotifications(ctx context.Context, db DBTX, till time.Time) ([]ListNotSentNotificationsRow, error) {
	rows, err := db.QueryContext(ctx, listNotSentNotifications, till)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListNotSentNotificationsRow
	for rows.Next() {
		var i ListNotSentNotificationsRow
		if err := rows.Scan(
			&i.EventID,
			&i.NextSending,
			&i.Text,
			&i.TgID,
			&i.NotificationRetryPeriodS,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
